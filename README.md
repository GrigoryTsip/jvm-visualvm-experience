Домашнее задание для Netology.ru для курса Java Developer   

Описание и инструкция к выполнению [здесь](https://github.com/netology-code/jd-homeworks/tree/master/jvm/README.md)

# Анализ использования памяти JVM

## Постановка задачи
Исследуется распределение памяти при загрузке в JVM класов и их экземпляров. Для этого используются классы, содержащиесяв пакетах io.vertex, io.netty и фреймворке org.springframework.
Запуск соответствующего кода приводил к загрузке в следующих вариантах:

- Вариант 1: 5 000 000 объектов каждого класса каждого пакета;
- Вариант 2: 500 000 объектов каждого класса каждого пакета;
- Вариант 3: 50 000 000 объектов каждого класса пакета io.vertex, 25 000 000 объектов каждого класса пакета io.netty, 1 500 000 объектов каждого класса фреймворка org.springframework.

Для каждого варианта исследовалось загруженность областей памяти Metaspace и Heap, а также отслеживалась загрузка классов по времени.

Исследование проводилось с применением приложения visualvm.

## Загрузка классов

Для всех вариантов количественные характеристики загрузки одинаковы, соответственно картина загрузки для всех вариантов одинакова (см. рисунки).

Вариант 1.

![](../jvm-visualvm-experience/Classes_1.png)

Вариант 2.

![](../jvm-visualvm-experience/Classes_2.png)

Вариант 3.

![](../jvm-visualvm-experience/Classes_3.png)

Как видно из рисунков, различия в графиках вызваны масштабом изображений. 
Скачки на графиках отражают переход от загрузки классов одного пакета к загрузке классов другого.

## Загрузка Metaspace

Здесь также количественные характеристики для всех вариантов совпадают, поскольку Metaspace содержит характеристики загружаемых классов. Соответственно графики загрузки идентичны.

Вариант 1.

![](../jvm-visualvm-experience/Metaspace_1.png)

Вариант 2.

![](../jvm-visualvm-experience/Metaspace_2.png)

Вариант 3.

![](../jvm-visualvm-experience/Metaspace_3.png)

Здесь также скачки на графиках связаны со сменой загрузки классов пакета. 

Отметим, что общий размер Metaspace практически соогтветствует используемому пространству памяти.

## Загрузка Heap

В куче формируются объекты, как экземпляры классов.

Вариант 1.

Загрузка 5 000 000 объектов каждого класса.

![](../jvm-visualvm-experience/Heap_1.png)

Как видно из графика, перед началом загрузки объектов использованная память в куче освобождается, а затем начинает заполняться новыми объектами. При этом по необходимости опережающими темпами увеличивается общий размер кучи. Загрузка объектов происходит достаточно быстро (здесь в среднем меньше миллисекунды), но, как видно из графика, после загрузки производится какая-то обработка, занимающая порядка 3 миллисекунд.

Вариант 2.

Загрузка 500 000 объектов каждого класса.

![](../jvm-visualvm-experience/Heap_2.png)

Здесь также отмечается резкое уменьшение размера кучи перед началом загрузки объектов. Обращает на себя внимание эффект уменьшения используемого пространства кучи при загрузке объектов первого пакета. Вероятно загрузка происходит на фоне работы сборщика мусора.

Загрузка объектов следующих двух пакетов уже приводит к скачкам используемой памяти кучи с опережающим ростом общего размера. При этом время между загрузками объектов пакетов не изменилось по сравнению с Вариантом 1 (3 мс).

Вариант 3.

Загрузка 

- 50 000 000 объектов каждого класса пакета io.vertex, 
- 25 000 000 объектов каждого класса пакета io.netty, 
- 1 500 000 объектов каждого класса фреймворка org.springframework.

![](../jvm-visualvm-experience/Heap_3.png)

Здесь картина иная:

- загрузка объектов первого пакета занимает более 3,5 мс,
- объекты второго пакета (их в 2 раза меньше) загружены за менее, чем за 2 мс
- для третего это время составляет 0,05 мс.

Таким образом, время загрузки объектов классов пропорционально их количеству, а время дополнительной обработки, все равно, остается порядка 3 мс.